---
## Front matter
title: "Отчет по лаборатной работе №9"
subtitle: "Дисциплина: архитектура компьютера"
author: "Желобицкая П.А."

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase,Scale=0.9
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Приобрести навыки написания программ с использованием подпрограмм. Познакомиться с методами откладки при помощи GDB и его основными возможностями.

# Выполнение лабораторной работы

Создаю каталог для выполнения лабораторной работы №9, перехожу в него и создаю файл lab9-1.asm (рис. @fig:001).

![Создание каталога и файла](image/1.png){#fig:001 width=70%}

Ввожу в файл lab9-1.asm текст программы  из листинга 9.1 (рис. @fig:002).

![Ввод текста программы](image/2.png){#fig:002 width=70%}

Создаю исполняемый файл, запускаю его и проверяю работу (рис. @fig:003).

![Запуск и проверка файла](image/3.png){#fig:003 width=70%}

Вношу изменения в текст программы (рис. @fig:004).

![Изменения текста программы](image/4.png){#fig:004 width=70%}

Создаю исполняемый файл, запускаю его и проверяю работу (рис. @fig:005).

![Запуск и проверка файла](image/5.png){#fig:005 width=70%}

Создаю файл lab9-2.asm (рис. @fig:006).

![Создание файла](image/6.png){#fig:006 width=70%}

Ввожу в файл текст программы из листинга 9.2 (рис. @fig:007).

![Ввод программы](image/9.png){#fig:007 width=70%}

Создаю исполняемый файл, загружаю его в откладчик gdb. Проверяю работу программы, запуская ее в оболочке GDB с помощью команды run (рис. @fig:008).

![Загрузка в откладчик gdb и запуск программы в оболочке GDB](image/inctead of 11 and 12.png){#fig:008 width=70%}

Устанавливаю брейкпоинт на метку _start (рис. @fig:009).

![Установка брейкпоинта](image/i13.png){#fig:009 width=70%}

Запускаю эту программу (рис. @fig:010).

![Запуск программы](image/i14.png){#fig:010 width=70%}

С помощью команды disassemble смотрю дисассимилированный код программы (рис. @fig:011).

![Просмотр дисассимилированного кода программы](image/i15.png){#fig:011 width=70%}

Переключаюсь на отображение команд с Intel'овским синтаксисом, с помощью команды disassemble (рис. @fig:012).

![Переключение на отображение команд с Intel'овским синтаксисом](image/i16.png){#fig:012 width=70%}

Основное различие заключается в том, что в режиме Intel пишется сначала сама команда, а потом уже ее машинный код, когда в режиме ATT идет сначала машинный код и уже потом сама команда.

Включаю режим псевдографики (рис. @fig:013).

![Режим псевдографики](image/i17.png){#fig:013 width=70%}

Команда layout regs (рис. @fig:014).

![Режим псевдографики](image/i18.png){#fig:014 width=70%} 

Проверяю точку останова с помощью команды info breakpoints (рис. @fig:015).

![Проверка точки останова](image/19.png){#fig:015 width=70%} 

Определяю адрес последней инструкции (mov ebx,0x0) и устанавливаю точку останова (рис. @fig:016).

![Адрес предпоследней инструкции](image/20.png){#fig:016 width=70%} 

Просматриваю информацию о всех установленных точках останова (рис. @fig:017).

![Информация о всех точках останова](image/21.png){#fig:017 width=70%}

Просматриваю содержимое регистров с помощью команды info registers (рис. @fig:018).

![Содержимое регистров](image/23.png){#fig:018 width=70%}

Просматриваю значение переменой msg1 по имени (рис. @fig:019).

![Значение переменной msg1 по имени](image/24.png){#fig:019 width=70%}

Просматриваю значение переменной msg2 по адресу (рис. @fig:020).

![Значение переменной msg2 по адресу](image/25.png){#fig:020 width=70%}

Изменяю первый символ переменной msg1 (рис. @fig:021).

![Изменение первого символа переменной msg1](image/26.png){#fig:021 width=70%}

Заменяю первый символ во второй переменной msg2 (рис. @fig:022).

![Замена второго символа в переменной msg2](image/27.png){#fig:022 width=70%}

Вывожу в различных форматах (в шестнадцатеричном, в двоичном форматах и в символьном виде) значение регистра ebx (рис. @fig:023).

![Выведение значений регистра ebx](image/28.png){#fig:023 width=70%}

Изменяю значение регистра ebx с помощью команды set (рис. @fig:024).

![Изменение значений регистра ebx](image/29.png){#fig:024 width=70%}

Завершаю выполнение программы с поощью команды continue или stepi и выхожу из GDB с помощью команды quit.

Копирую файл lab8-2.asm в файл lab9-3.asm и создаю исполняемый файл (рис. @fig:025).

![Копирование и создание исполняемого файла](image/30.png){#fig:025 width=70%}

Загружаю исполняемый файл в откладчик, указывая аргументы (рис. @fig:026).

![Загрузка исполняемого файла в откладчик](image/31.png){#fig:026 width=70%}

Устанавливаю точку останова перед первой инструкцией в программе и запускаю ее (рис. @fig:027).

![Запуск программы](image/32.png){#fig:027 width=70%}

Адрес вершины стека храниться в регистре esp и по этому адресу располагается число
равное количеству аргументов командной строки (рис. @fig:028).

![Адрес вершины стека](image/33.png){#fig:028 width=70%}

Просматриваю остальные позиции стека (рис. @fig:029).

![Остальные позиции стека](image/34.png){#fig:029 width=70%}

Количество аргументов командной строки 4, значит и шаг равен 4.

# Выполнение заданий самостоятельной работы

Преобразую программу из лабораторной работы №8, добавляю подпрограмму, которая вычисляет знаения функции f(x) (рис. @fig:030).

![Редактирование файла](image/ii35!!!!!!!.png){#fig:030 width=70%}

Создаю исполняемый файл и ввожу аргументы. Получаю верный ответ (рис. @fig:031).

![Создание исполняемого файла и проверка его](image/36.png){#fig:031 width=70%}

Создаю файл lab9-5.asm (рис. @fig:032).

![Создание файла](image/37.png){#fig:032 width=70%}

Ввожу в этот файл текст программы из листинга 9.3 (рис. @fig:033).

![Ввод текста программы](image/38.png){#fig:033 width=70%}

Открываю файл в откладчике GDB и запускаю программу (рис. @fig:034).

![Запуск программы в откладчике](image/39.png){#fig:034 width=70%}

Просматриваю дисассимилированный код программы, ставлю точку останова перед прибавлением 5 и открываю значения регистров на данном этапе (рис. @fig:035).

![Действия в откладчике](image/40.png){#fig:035 width=70%}

Регистр ecx со значением 4 умножается не на ebx, сложенным с eax,  а только с eax со значением 2. Следовательно, нужно поменять значения регистров (рис. @fig:036).

![Изменения в программе](image/41.png){#fig:036 width=70%}

Запускаю программу и получаю верный ответ (рис. @fig:037).

![Запуск и проверка программы](image/42.png){#fig:037 width=70%}

Описываются проведённые действия, в качестве иллюстрации даётся ссылка на иллюстрацию (рис. @fig:001).

![Название рисунка](image/placeimg_800_600_tech.jpg){#fig:001 width=70%}

# Выводы

я приобрела навыки написания программ с использованием подпрограмм. Ознакомилась с методами откладки при помощи GDB и его основными возможностями.

# Список литературы{.unnumbered}

::: {#refs}
:::
